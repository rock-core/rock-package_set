Index: ukfom/mtkwrap.hpp
===================================================================
--- ukfom/mtkwrap.hpp	(revision 25)
+++ ukfom/mtkwrap.hpp	(working copy)
@@ -48,7 +48,7 @@
 
 
 // import most common Eigen types 
-USING_PART_OF_NAMESPACE_EIGEN
+using namespace Eigen;
 
 
 /**
@@ -59,8 +59,8 @@
 struct mtkwrap : public M{
 	typedef mtkwrap<M> self;
 public:
-	typedef double scalar; // MTK only works with double
-	typedef scalar scalar_type;
+	//typedef double scalar; // MTK only works with double
+	typedef typename M::scalar scalar_type;
 
 	enum {
 		DOF = M::DOF
@@ -77,7 +77,7 @@
 	 */
 	self& operator+=(const vectorized_type &delta_state)
 	{
-		assert(delta_state.stride() == DOF);
+		assert(delta_state.size() == DOF);
 		M::boxplus(delta_state.data());
 		return *this;
 	}
@@ -96,7 +96,7 @@
 	const vectorized_type operator-(const self &other) const
 	{
 		vectorized_type result;
-		assert(result.stride()==DOF);
+		assert(result.rows()==DOF);
 		M::boxminus(result.data(), other);
 
 		return result;
Index: ukfom/ukf.hpp
===================================================================
--- ukfom/ukf.hpp	(revision 25)
+++ ukfom/ukf.hpp	(working copy)
@@ -43,8 +43,12 @@
 #include <boost/bind.hpp>
 
 #include <Eigen/Core>
-#include <Eigen/LU> 
+#include <Eigen/LU>
 
+#if EIGEN_VERSION_AT_LEAST(3,0,0)
+    #include <Eigen/Eigenvalues>
+#endif
+
 #include <Eigen/QR>
 
 #include "lapack/cholesky.hpp"
@@ -54,7 +58,7 @@
 namespace ukfom {
 	
 // import most common Eigen types 
-USING_PART_OF_NAMESPACE_EIGEN
+using namespace Eigen;
 
 template <typename state>
 class ukf {
@@ -90,7 +94,7 @@
 		state_vector X(2 * n + 1);
 		generate_sigma_points(mu_, sigma_, X);
 		
-		std::transform(X.begin(), X.end(), X.begin(), g);
+	        std::transform(X.begin(), X.end(), X.begin(), g);
 
 		mu_ = sigma_points_mean(X);
 
@@ -149,7 +153,7 @@
 		const cross_cov covXZ = sigma_points_cross_cov<measurement_rows>(mu_, meanZ, X, Z);
 
 		measurement_cov S_inverse;
-		S.computeInverse(&S_inverse);
+		S_inverse = S.inverse();
 
 		const cross_cov K = covXZ * S_inverse;
 		
@@ -196,8 +200,9 @@
 		
 		assert(L.isSPD());
 
+		
 		/*
-		std::cout << ">> L" << std::endl
+               std::cout << ">> L" << std::endl
 				  << L.getL() << std::endl
 				  << "<< L" << std::endl;
 		*/
Index: ukfom/lapack/cholesky.hpp
===================================================================
--- ukfom/lapack/cholesky.hpp	(revision 25)
+++ ukfom/lapack/cholesky.hpp	(working copy)
@@ -43,7 +43,7 @@
 namespace lapack {
 
 // import most common Eigen types 
-USING_PART_OF_NAMESPACE_EIGEN
+using namespace Eigen;
 
 template<size_t M>
 class cholesky
Index: ukfom/lapack/invert.hpp
===================================================================
--- ukfom/lapack/invert.hpp	(revision 25)
+++ ukfom/lapack/invert.hpp	(working copy)
@@ -43,7 +43,7 @@
 namespace lapack {
 
 // import most common Eigen types 
-USING_PART_OF_NAMESPACE_EIGEN
+using namespace Eigen;
 
 template<size_t P>
 Matrix<double, P, P> invert(const Matrix<double, P, P> &m)
Index: example/CMakeLists.txt
===================================================================
--- example/CMakeLists.txt	(revision 25)
+++ example/CMakeLists.txt	(working copy)
@@ -1,4 +1,4 @@
-include_directories( ${EIGEN2_INCLUDE_DIR} )
+include_directories( ${Eigen3_INCLUDE_DIRS} )
 INCLUDE_DIRECTORIES( ${CMAKE_SOURCE_DIR})
 INCLUDE_DIRECTORIES( ${CMAKE_SOURCE_DIR}/slom)
 
Index: mtk/src/vectview.hpp
===================================================================
--- mtk/src/vectview.hpp	(revision 25)
+++ mtk/src/vectview.hpp	(working copy)
@@ -69,9 +69,14 @@
 	//! construct from another @c vectview
 	vectview(const vectview &v) : base(v) {}
 	//! construct from Eigen::Block:
-#if MTK_EIGEN >= 300
+#if EIGEN_VERSION_AT_LEAST(3,2,0)
 	template<class Base>
 	vectview(Eigen::VectorBlock<Base, dim> block) : base(&block.coeffRef(0)) {}
+	template<class Base, bool PacketAccess>
+	vectview(Eigen::Block<Base, dim, 1, PacketAccess> block) : base(&block.coeffRef(0)) {}
+#elif EIGEN_VERSION_AT_LEAST(3,0,0)
+	template<class Base>
+	vectview(Eigen::VectorBlock<Base, dim> block) : base(&block.coeffRef(0)) {}
 	template<class Base, bool PacketAccess, bool DirectAccessStatus>
 	vectview(Eigen::Block<Base, dim, 1, PacketAccess, DirectAccessStatus> block) : base(&block.coeffRef(0)) {}
 #else
@@ -118,9 +123,14 @@
 	 * Construct from Block
 	 * @todo adapt this, when Block gets const-correct
 	 */
-#if MTK_EIGEN >= 300
+#if EIGEN_VERSION_AT_LEAST(3,2,0)
 	template<class Base>
 	vectview(Eigen::VectorBlock<Base, dim> block) : base(&block.coeffRef(0)) {}
+	template<class Base, bool PacketAccess>
+	vectview(Eigen::Block<Base, dim, 1, PacketAccess> block) : base(&block.coeffRef(0)) {}
+#elif EIGEN_VERSION_AT_LEAST(3,0,0)
+	template<class Base>
+	vectview(Eigen::VectorBlock<Base, dim> block) : base(&block.coeffRef(0)) {}
 	template<class Base, bool PacketAccess, bool DirectAccessStatus>
 	vectview(Eigen::Block<Base, dim, 1, PacketAccess, DirectAccessStatus> block) : base(&block.coeffRef(0)) {}
 #else
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(revision 25)
+++ CMakeLists.txt	(working copy)
@@ -1,34 +1,26 @@
-CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
+cmake_minimum_required(VERSION 2.6)
+project(mtk)
 
+add_definitions(-Wall -Wno-unused-function -march=native -msse2 -mssse3 -mfpmath=sse)
+option(SLOM_BUILD_EXAMPLES "Build the example code" OFF)
+if (SLOM_BUILD_LIBONLY)
+    set(SLOM_BUILD_EXAMPLES OFF)
+endif()
 
-IF(NOT CMAKE_BUILD_TYPE)
-  SET(CMAKE_BUILD_TYPE RELEASE CACHE STRING
-      "Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel."
-      FORCE)
-ENDIF(NOT CMAKE_BUILD_TYPE)
+list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake_modules)
 
-IF(NOT SLOM_BUILD_LIBONLY)
-	SET(CMAKE_CXX_FLAGS_DEBUG  "-ggdb -O0 -Wall -march=native -msse2 -mfpmath=sse")
-	SET(CMAKE_CXX_FLAGS_RELEASE  "-ggdb -O3 -Wall -Wno-unused-function -march=native -msse2 -mssse3 -mfpmath=sse")
-	SET(SLOM_BUILD_EXAMPLES ON)
-ENDIF(NOT SLOM_BUILD_LIBONLY)
-
-
-# find include dirs:
-
-SET(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake_modules)
-
 FIND_PACKAGE(CXSparse REQUIRED) 
-FIND_PACKAGE(Eigen2)
-FIND_PACKAGE(Boost 1.36.0 REQUIRED COMPONENTS program_options unit_test_framework)
+FIND_PACKAGE(LAPACK)
+find_package(PkgConfig)
+pkg_check_modules(Eigen3 REQUIRED eigen3)
 
 INCLUDE_DIRECTORIES(${CXSPARSE_INCLUDE_DIR} )
-INCLUDE_DIRECTORIES(${EIGEN2_INCLUDE_DIR} )
+INCLUDE_DIRECTORIES(${Eigen3_INCLUDE_DIRS} )
 INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR} )
 
 INCLUDE_DIRECTORIES(${Boost_INCLUDE_DIRS})
 
-ADD_LIBRARY( slom STATIC slom/src/Estimator.cpp slom/src/SparseFunction.cpp)
+ADD_LIBRARY(slom slom/src/Estimator.cpp slom/src/SparseFunction.cpp)
 
 
 TARGET_LINK_LIBRARIES(slom
@@ -36,10 +28,50 @@
 )
 
 IF(SLOM_BUILD_EXAMPLES)
-	ENABLE_TESTING()
-	ADD_EXECUTABLE( min_example doc/example.cpp)
-	TARGET_LINK_LIBRARIES(min_example slom)
-	
-	ADD_SUBDIRECTORY (example)
-	ADD_SUBDIRECTORY (unit_test)
+    FIND_PACKAGE(Boost 1.36.0 REQUIRED COMPONENTS program_options unit_test_framework)
+    ENABLE_TESTING()
+    ADD_EXECUTABLE( min_example doc/example.cpp)
+    TARGET_LINK_LIBRARIES(min_example slom)
+
+    ADD_SUBDIRECTORY (example)
+    ADD_SUBDIRECTORY (unit_test)
 ENDIF()
+
+INSTALL(FILES
+    mtk/startIdx.hpp
+    mtk/build_manifold.hpp
+    mtk/mean_and_covar.hpp
+    DESTINATION include/mtk)
+
+INSTALL(FILES
+    mtk/src/eigen.hpp
+    mtk/src/mtkmath.hpp
+    mtk/src/SubManifold.hpp
+    mtk/src/vectview.hpp
+    DESTINATION include/mtk/src)
+
+INSTALL(FILES
+    mtk/types/pose.hpp
+    mtk/types/S2.hpp
+    mtk/types/SOn.hpp
+    mtk/types/vect.hpp
+    DESTINATION include/mtk/types)
+
+INSTALL(FILES
+    ukfom/mtkwrap.hpp
+    ukfom/util.hpp
+    ukfom/ukf.hpp
+    DESTINATION include/ukfom)
+
+INSTALL(FILES
+    ukfom/lapack/cholesky.hpp
+    ukfom/lapack/invert.hpp
+    ukfom/lapack/lapack.h
+    DESTINATION include/ukfom/lapack)
+
+INSTALL(FILES
+    ukfom/traits/dof.hpp
+    DESTINATION include/ukfom/traits)
+
+install(TARGETS slom
+    DESTINATION lib)
Index: unit_test/CMakeLists.txt
===================================================================
--- unit_test/CMakeLists.txt	(revision 25)
+++ unit_test/CMakeLists.txt	(working copy)
@@ -1,4 +1,4 @@
-include_directories( ${EIGEN2_INCLUDE_DIR} )
+include_directories( ${EIGEN3_INCLUDE_DIR} )
 INCLUDE_DIRECTORIES( ${CMAKE_SOURCE_DIR})
 
 INCLUDE_DIRECTORIES( ${CMAKE_SOURCE_DIR}/slom)
@@ -6,14 +6,16 @@
 
 
 MACRO(MAKE_TEST name scalar)
-	ADD_TEST(${name}_${scalar} ${name}_${scalar})
+        ADD_TEST(${name}_${scalar} ${name}_${scalar})
 	ADD_EXECUTABLE(${name}_${scalar} ${name}.cc)
 	SET_TARGET_PROPERTIES(${name}_${scalar} PROPERTIES COMPILE_FLAGS -DSCALAR=${scalar})
-	TARGET_LINK_LIBRARIES(${name}_${scalar} boost_unit_test_framework-mt)
+        TARGET_LINK_LIBRARIES(${name}_${scalar} boost_unit_test_framework-mt ${LAPACK_LIBRARIES})
 ENDMACRO()
 
 
 MAKE_TEST(mtk_test float)
 MAKE_TEST(mtk_test double)
 MAKE_TEST(slom_choleskytest double)
+MAKE_TEST(ukfom_test double)
 
+

===================================================================
--- mtk/types/vect.hpp	2014-10-23 13:40:35.893320788 +0200
+++ mtk/types/vect.hpp	2014-10-22 21:05:03.000000000 +0200
@@ -42,21 +42,27 @@
 #define VECT_H_
 
 #include <iosfwd>
+#include <iostream>
+#include <vector>
 
 #include "../src/vectview.hpp"
 
 namespace MTK {
 
+static const Eigen::IOFormat IO_no_spaces(Eigen::StreamPrecision, Eigen::DontAlignCols, ",", ",", "", "", "[", "]");
+
+
 /**
  * A simple vector class.
  * Implementation is basically a wrapper around Eigen::Matrix with manifold 
  * requirements added.
  */
-template<int D, class _scalar = double>
-struct vect : public Eigen::Matrix<_scalar, D, 1> {
-	typedef Eigen::Matrix<_scalar, D, 1> base;
+template<int D, class _scalar = double, int _Options=Eigen::AutoAlign>
+struct vect : public Eigen::Matrix<_scalar, D, 1, _Options> {
+	typedef Eigen::Matrix<_scalar, D, 1, _Options> base;
 	enum {DOF = D};
 	typedef _scalar scalar;
+        typedef Eigen::Matrix<scalar, D, 1> vectorized_type;
 	
 	using base::operator=;
 	
@@ -67,50 +73,81 @@
 	
 	/** Constructor copying the value of the expression \a other */
 	template<typename OtherDerived>
-	EIGEN_STRONG_INLINE vect(const Eigen::MatrixBase<OtherDerived>& other) : base(other) {}
+	EIGEN_STRONG_INLINE vect(const Eigen::DenseBase<OtherDerived>& other) : base(other) {}
 	
 	/** Construct from memory. */
-	vect(const scalar* src) : base(src) { }
+	vect(const scalar* src, int size = DOF) : base(base::Map(src, size)) { }
 	
-	void boxplus(MTK::vectview<const scalar, DOF> vec, scalar scale=1) {
+	void boxplus(MTK::vectview<const scalar, D> vec, scalar scale=1) {
 		*this += scale * vec;
 	}
-	void boxminus(MTK::vectview<scalar, DOF> res, const vect<D, scalar>& other) const {
+	void boxminus(MTK::vectview<scalar, D> res, const vect<D, scalar>& other) const {
 		res = *this - other;
 	}
 	
 	
-	friend std::ostream& operator<<(std::ostream &os, const vect<D, scalar>& v){
-		// Old versions of Eigen messed up with the streams flags, so do it manually:
-		for(int i=0; i<DOF; ++i)
-			os << v(i) << " ";
-		return os;
-	}
-	friend std::istream& operator>>(std::istream &is, vect<D, scalar>& v){
-		for(int i=0; i<DOF; ++i)
-			is >> v(i);
+	friend std::ostream& operator<<(std::ostream &os, const vect<D, scalar, _Options>& v){
+		// Eigen sometimes messes with the streams flags, so output manually:
+                for(int i=0; i<v.size(); ++i)
+                        os << v(i) << " ";
+                return os;
+	}
+	friend std::istream& operator>>(std::istream &is, vect<D, scalar, _Options>& v){
+		char term=0;
+		is >> std::ws; // skip whitespace
+		switch(is.peek()) {
+		case '(': term=')'; is.ignore(1); break;
+		case '[': term=']'; is.ignore(1); break;
+		case '{': term='}'; is.ignore(1); break;
+		default: break;
+		}
+		if(D==Eigen::Dynamic) {
+			assert(term !=0 && "Dynamic vectors must be embraced");
+			std::vector<scalar> temp;
+			while(is.good() && is.peek() != term) {
+				scalar x;
+				is >> x;
+				temp.push_back(x);
+				if(is.peek()==',') is.ignore(1);
+			}
+			v = vect::Map(temp.data(), temp.size());
+		} else
+			for(int i=0; i<v.size(); ++i){
+				is >> v[i];
+				if(is.peek()==',') { // ignore commas between values
+					is.ignore(1);
+				}
+			}
+		if(term!=0) {
+			char x;
+			is >> x;
+			if(x!=term) {
+				is.setstate(is.badbit);
+//				assert(x==term && "start and end bracket do not match!");
+			}
+		}
 		return is;
 	}
 	
 	template<int dim>
 	vectview<scalar, dim> tail(){
 		BOOST_STATIC_ASSERT(0< dim && dim <= DOF);
-		return base::data() + (DOF - dim);
+		return base::template tail<dim>();
 	}
 	template<int dim>
 	vectview<const scalar, dim> tail() const{
 		BOOST_STATIC_ASSERT(0< dim && dim <= DOF);
-		return base::data() + (DOF - dim);
+		return base::template tail<dim>();
 	}
 	template<int dim>
 	vectview<scalar, dim> head(){
 		BOOST_STATIC_ASSERT(0< dim && dim <= DOF);
-		return base::data();
+		return base::template head<dim>();
 	}
 	template<int dim>
 	vectview<const scalar, dim> head() const{
 		BOOST_STATIC_ASSERT(0< dim && dim <= DOF);
-		return base::data();
+		return base::template head<dim>();
 	}
 };
 
@@ -217,7 +254,56 @@
 	}
 };
 
+template<class _scalar = double>
+struct Complex : public std::complex<_scalar>{
+	enum {DOF = 2};
+	typedef _scalar scalar;
+	
+	typedef std::complex<scalar> Base;
+	
+	Complex(const Base& value) : Base(value) {}
+	Complex(const scalar& re = 0.0, const scalar& im = 0.0) : Base(re, im) {}
+	Complex(const MTK::vectview<const scalar, 2> &in) : Base(in[0], in[1]) {}
+	template<class Derived>
+	Complex(const Eigen::DenseBase<Derived> &in) : Base(in[0], in[1]) {}
+	
+	void boxplus(MTK::vectview<const scalar, DOF> vec, scalar scale=1) {
+		Base::real()+= scale * vec[0];
+		Base::imag()+= scale * vec[1];
+	};
+	void boxminus(MTK::vectview<scalar, DOF> res, const Complex& other) const {
+		Complex diff = *this - other;
+		res << diff.real(), diff.imag();
+	}
+	
+	scalar squaredNorm() const {
+		return std::pow(Base::real(),2) + std::pow(Base::imag(),2);
+	}
+	
+	const scalar& operator()(int i) const {
+		assert(0<=i && i<2 && "Index out of range");
+		return i==0 ? Base::real() : Base::imag();
+	}
+	scalar& operator()(int i){
+		assert(0<=i && i<2 && "Index out of range");
+		return i==0 ? Base::real() : Base::imag();
+	}
+};
+
+
+namespace internal {
+
+//template<int dim, class Scalar, int Options>
+//struct UnalignedType<vect<dim, Scalar, Options > >{
+//	typedef vect<dim, Scalar, Options | Eigen::DontAlign> type;
+//};
+
+}  // namespace internal
+
+
 }  // namespace MTK
 
 
+
+
 #endif /*VECT_H_*/
